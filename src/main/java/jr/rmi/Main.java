package jr.rmi;

import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

public class Main {
    // в переменной UNIC_BINDING_NAME храним придуманное нами уникальное имя нашего
    // удаленного объекта (объекта, который доступен удаленно). Если программа шарит
    // несколько объектов, у каждого должно быть свое уникальное имя.
    // Уникальное имя нашего объекта — «server.reverse».
    public static final String UNIQUE_BINDING_NAME = "server.reverse";

    public static void main(String[] args) throws Exception {
        // создание объекта для удаленного доступа
        // собственно, создаем объект ReverseImpl,
        // который будет доступен удаленно, и чьи методы будут вызваться.
        final ReverseImpl service = new ReverseImpl();

        // создание реестра расшареных объектов
        // создаем специальный объект – реестр. В нем надо регистрировать объекты,
        // которые мы шарим. Дальше ими занимается Java-машина. 2099 – это порт (уникальный номер,
        // по которому другая программа может обратиться к нашему реестру объектов).
        final Registry registry = LocateRegistry.createRegistry(2099);

        // создание "заглушки" – приемника удаленных вызовов
        // создание «заглушки». Заглушка – это специальный объект,
        // который принимает информацию об удаленном вызове, распаковывает ее,
        // десериализует переданные параметры методов и вызывает нужный метод.
        // Затем сериализует результат или исключение, если оно было, и отсылает все это назад вызывающему.
        Remote stub = UnicastRemoteObject.exportObject(service, 0);

        // регистрация "заглушки" в реесте
        // регистрируем в реестре заглушку нашего объекта под уникальным именем.
        registry.bind(UNIQUE_BINDING_NAME, stub);

        // усыпляем главный поток, иначе программа завершится
        // усыпляем главный поток. Все удалённые вызовы обрабатываются
        // в отдельных нитях. Главное, чтобы программа в это время
        // работала. Так что тут просто отправляем главную нить спать, и всё.
        Thread.sleep(Integer.MAX_VALUE);
    }
}
